function [explainedVariance, explainedVariance_shifted] = ...
    receptiveFieldShiftTest(traces, traceTimes, ...
    stimFrames, stimTimes, RFtimesInFrames, ...
    runSpeed, runTime, runKernels, runWin, receptiveFields, lambdas, numShifts)

%RECEPTIVEFIELDSHIFTTEST Test significance of receptive field fit.
%   [explainedVariance, explainedVariance_shifted] = ...
%    RECEPTIVEFIELDSHIFTTEST(traces, traceTimes, stimFrames, stimTimes, ...
%    RFtimesInFrames, runSpeed, runTime, runKernels, runWin, ...
%    receptiveFields, lambdas, numShifts) determines explained variance of
%    neural traces given their receptive fields, and explained variance of
%    surrogate data generated by shifting the neural traces in time.
%
%   explainedVariance   [neuron x 1], each entry:
%                       explained variance for fitted RF for each neuron
%   explainedVariance_shifted   [neuron x numShifts], 
%                       each entry: explained variance for each neuron and
%                       shift of neural response to stimulus
%
%   traces              [trTime x neuron]; calcium traces of neurons
%   traceTimes          [trTime x 1]; sample times of calcium traces
%   stimFrames          [time x rows x cols]; noise stimulus
%   stimTimes           [1 x time]; times of stimulus frames
%   RFtimesInFrames     [1 x RFframes]; frames of receptive field relative
%                       to stimulus frames
%   runSpeed            [rTime x 1]; running speed
%   runTime             [rTime x 1]; time points of running speed
%   runKernels          [t x neuron]; containing linear
%                       regression kernel fitting calcium based on running
%                       speed
%   receptiveFields     [rows x columns x t x 2 x neuron]; fitted receptive
%                       fields
%   lambdas             [neuron x 1]; optimal lambda for RF fitting found
%                       with cross-validation
%   numShifts           int; number of shifts to generate null
%                       distributions

% find time gaps in stimulus presentation (usually when same visual noise
% stimulus was repeated several times)
stimBin = median(diff(stimTimes));
indGap = find(diff(stimTimes) > 2 * stimBin);
time = stimTimes;
% fill gaps with zeros in stimulus matrix
for g = 1:length(indGap)
    add = round(diff(stimTimes(indGap(g) + [0 1])) ./ stimBin);
    stimFrames = [stimFrames(1:indGap(g),:,:); ...
        zeros(add, size(stimFrames,2), size(stimFrames,3)); ...
        stimFrames(indGap(g)+1:end,:,:)];
    time = [time(1:indGap(g)); ...
        time(indGap(g)) + (1:add)' .* stimBin; ...
        time(indGap(g)+1:end)];
end
% reshape stimulus frames to [time x px]; this represents a single
% "stimulus block", i.e. the pixels to estimate a single time point of the
% receptive field
stim = reshape(stimFrames, size(stimFrames,1), []);
% now concatinate time shifted stimulus blocks; for each time point there
% is a stimulus block for lag=0, another for lag=-1, another for lag=-2,...
st = [];
for t = 1:length(RFtimesInFrames)
    st = [st, ...
        [zeros(max(0,RFtimesInFrames(1)-1+t), size(stim,2)); ...
        stim(max(1,2-RFtimesInFrames(1)-t) : end-RFtimesInFrames(1)-t+1, :)]];
end
stim = st;
clear st

% generate Toeplitz matrix for running speed
% filter running speed
runSpeed = medfilt1(runSpeed, 5);
% resample running speed at time points of neural traces
runBin = median(diff(runTime));
numBins = round(stimBin / runBin);
runSpeed = smooth(runSpeed, numBins);
runSpeed = interp1(runTime, runSpeed, time, 'pchip');
runToepl =  krnl.getToeplitz(time, [], [], {runSpeed}, ...
    {runWin([1 end])}, true);
% z-score
runToepl = (runToepl - mean(runToepl(:))) ./ std(runToepl);

% get neural response
traceBin = median(diff(traceTimes));
numBins = round(stimBin / traceBin);
traces = smoothdata(traces, 1, 'movmean', numBins, 'omitnan');
traces = interp1(traceTimes, traces, time);
% z-score neural response
zTraces = (traces - nanmean(traces,1)) ./ nanstd(traces,0,1);

% delete stim frames for which all neurons have NaN
ind = all(isnan(zTraces),2);
stim(ind,:) = [];
zTraces(ind,:) = [];
runToepl(ind,:) = [];
% if NaN values < 5% in a neuron, exchange NaNs for 0
ind = any(isnan(zTraces),1) & sum(isnan(zTraces),1)/size(zTraces,1) <= 0.05;
if sum(ind) > 0
    zTraces(:,ind) = fillmissing(zTraces(:,ind),'constant',0);
end
% skip neurons that have only NaN values
valid = ~all(isnan(zTraces),1)';

% subtract running predictions from traces
pred = runToepl * runKernels;
zTraces = zTraces - pred;

% duplicate stimulus matrix to predict ON part (1st half) and OFF part (2nd half)
s = stim;
s(stim < 0) = 0;
stim2 = s;
s = stim;
s(stim > 0) = 0;
stim2 = [stim2, s];
stim2 = (stim2 - nanmean(stim2(:))) ./ nanstd(stim2(:)); % normalise each column of stimulus matrix
clear s

% scale lambdas according to number of samples and number of predictors
lamStim = sqrt(lambdas .* size(stim,1) .* size(stim,2));

% construct spatial smoothing lambda matrix
lamMatrix_stim = krnl.makeLambdaMatrix([size(stimFrames,2), size(stimFrames,3), ...
    length(RFtimesInFrames)], [1 1 0]);
lamMatrix_stim = blkdiag(lamMatrix_stim, lamMatrix_stim);

% reshape receptive fields
receptiveFields = reshape(receptiveFields, [], size(receptiveFields, 5));

% get explained variances on original and shifted data
explainedVariance = NaN(size(traces,2), 1);
explainedVariance_shifted = NaN(size(traces,2), numShifts);

lamValues = unique(lamStim);
shifts = randi(size(zTraces,1), numShifts, 1);
shiftedTraces = NaN(size(zTraces,1), numShifts, size(zTraces,2));
for sh = 1:numShifts
    shiftedTraces(:,sh,:) = circshift(zTraces, shifts(sh), 1);
end
for lam = 1:length(lamValues)
    indNeurons = find((lamStim == lamValues(lam)) & valid);
    if isempty(indNeurons)
        continue
    end
    lms = lamMatrix_stim .* lamValues(lam);
    A = gpuArray([stim2; lms]);
    
    pred = stim2 * receptiveFields(:,indNeurons);
    explainedVariance(indNeurons) = 1 - ...
        sum((zTraces(:, indNeurons) - pred) .^ 2,1) ./ ...
        sum((zTraces(:, indNeurons) - mean(zTraces(:, indNeurons),1)) .^ 2,1);
    
    for iCell = 1:length(indNeurons)
        tr = shiftedTraces(:,:,indNeurons(iCell));
        B = gather(A \ gpuArray(padarray(tr, size(lms,1), 'post'))); 
        pred = stim2 * B;
        explainedVariance_shifted(indNeurons(iCell), :) = 1 - ...
            sum((tr - pred) .^ 2,1) ./ sum((tr - mean(tr,1)) .^ 2,1);
    end
end